프로젝트 컨텍스트

크롬 익스텐션(MV3), 대상: youtube.com/watch*, youtu.be/* (쇼츠 제외)

기능: A-B 구간 반복, 구간별 속도, 자동 저장 및 불러오기, 단축키, 탭 템포, 메트로놈, 카운트인

핵심 원칙(가드레일)

MV3 유지, remote code 금지

Overlay는 Shadow DOM을 사용해 스타일 오염 방지

루프 로직은 LoopController(또는 content.js의 루프 전담 모듈)에서만 변경

저장 스키마: VideoProfile(videoId, defaultRate, segments[], activeSegmentId, bpm, countInBeats, metronomeEnabled, schemaVersion)

권한/호스트 권한은 증가시키지 않음

비목표 (Non-Goals)

동영상 다운로드, 자막 자동 생성/싱크, Shorts/Live 전체 지원

광고 차단, 프리미엄 기능 우회

복잡한 ML 기반 오디오 분석

Definition of Done (DoD)

수락 기준(AC) 충족

기존 동작 회귀 없음(간단한 E2E 시나리오 통과)

권한/번들 크기 증가 없음(필요 시 사전 합의)

문서 및 CHANGELOG 갱신

커밋/브랜치

Conventional Commits: feat:, fix:, refactor:, docs:, test:, chore:

브랜치: main(배포), dev(통합), feat/*, fix/*

파일 경계 (중요)

content.js: DOM/YouTube 제어, 키바인딩, 오버레이 UI 연결

storage.js: chrome.storage.sync 래퍼와 마이그레이션

overlay.css: 오버레이 전용 스타일

background.js: commands 라우팅(필요 시)

새 기능 추가 시 새 파일 최소화, 기존 경계 안에서 구현

변경 시 금지 사항

매니페스트 권한 추가/호스트 권한 확대

DOM 전역 스타일 오염(Shadow DOM 외부 스타일 변경)

루프 판정 코드를 여러 곳에서 중복 구현

대형 라이브러리 도입(번들 급증)

이슈/PR 작업 템플릿 (Cursor에 붙여서 시작)

역할: 너는 이 저장소의 유지보수 엔지니어다. 가드레일을 넘지 마라.
요청: [버그/기능/리팩터 한 줄]
배경: [재현 단계 또는 현재 vs 기대 동작]
수락 기준(AC):
1) …
2) …
3) 성능/권한 영향 없음
비목표: …
작업 범위:
- [파일 경로/모듈] 중심으로, 필요한 최소 유틸만 추가
출력 형식:
1) 변경 요약(불릿)
2) 변경 파일 목록
3) 패치(diff)만 제시
4) 실행/테스트 방법(간단)
주의:
- VideoProfile 스키마 호환 유지, 필요 시 schemaVersion + 마이그레이션 추가
- 스타일/네이밍 기존 컨벤션 준수

테스트 최소 요건

단위: parseVideoId, 루프 경계 처리, storage 마이그레이션

수동 E2E 체크리스트:

구간 저장/재방문 자동 적용

겹치는 구간에서 활성 구간 우선 적용

단축키 동작(Play/Pause, Loop 토글, Prev/Next, Rate ±)

메트로놈/카운트인 작동

코드 스타일

명확한 함수명, 조기 반환(prefer), 상수/헬퍼 분리

DOM 선택자/이벤트 바인딩 한 곳에서 관리

매직 넘버(0.01 등) 상수화

성능/안정성

timeupdate 내 연산 최소화(필요 시 throttle)

YouTube SPA 네비게이션 감지(popstate/MutationObserver) 후 재바인딩

광고/엘리먼트 교체 감지, video 재획득 처리





바이브코딩 유지보수 팁 (Cursor/Claude 등 활용)

문제와 목표 명확화

만들고자 하는 기능, 수정할 버그를 구체적으로 정의.

“무엇을, 왜, 어디까지”를 작업 전에 확실히 파악.

수락 기준(AC)을 수치나 조건으로 명시 (예: ±0.01s 오차 이내, 클릭 후 200ms 내 반응 등).

작업 단위 최소화

한번에 많은 파일 수정 금지.

버그 1건 → 수정 → 테스트 통과 → 머지 후 다음 작업.

중간 방향 점검

AI가 코드를 변경하기 전에 계획을 먼저 출력하게 함.

중간에 문제를 새로 발견하면 즉시 방향 재조정.

컨텍스트 우선 제공

AI에 .cursorrules, 데이터 스키마, 현재 구조, 변경 범위를 먼저 입력.

예: “이 기능은 content.js 안에서만 변경, storage.js는 수정 금지”

테스트 주도

수정 전 재현 코드/시나리오 작성.

수정 후 테스트 통과 여부로 판단.

회귀 방지

재현된 버그는 테스트로 고정.

이후 동일 문제 자동 감지.

변경 기록 관리

큰 변경은 ADR로 기록: 목적, 대안, 선택 이유, 트레이드오프 간단히.

정기적인 리팩터링 검토

기능 추가 전후 코드 일관성, 네이밍, 모듈 경계 점검.

필요 시 AI로 “리팩터 제안만” 받기.

버전 관리 규칙 유지

Git 브랜치 전략: main, dev, feat/*, fix/*

Conventional Commits 규칙 적용.

AI 작업 요청 템플릿 고정

역할: [유지보수 엔지니어]
요청: [버그/기능]
배경: [현재 vs 기대 동작]
AC: [목록]
범위: [파일/모듈 제한]
주의: [가드레일 위반 금지]

문서 최신화

.cursorrules와 README는 가드레일, 스키마 변경, 지원 범위 변동 시 즉시 업데이트.